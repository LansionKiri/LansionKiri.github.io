<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python基本语法</title>
      <link href="/title.html"/>
      <url>/title.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据类型和变量-Data-types-and-variables"><a href="#数据类型和变量-Data-types-and-variables" class="headerlink" title="数据类型和变量 Data types and variables"></a>数据类型和变量 Data types and variables</h1><h2 id="标准数据类型-Standard-data-type"><a href="#标准数据类型-Standard-data-type" class="headerlink" title="标准数据类型 Standard data type"></a>标准数据类型 Standard data type</h2><h3 id="数值-Number"><a href="#数值-Number" class="headerlink" title="数值 Number"></a><strong>数值 Number</strong></h3><ul><li>int 整型数据 整数</li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(type(<span class="number">2</span>),<span class="string">':'</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>  输出：<code>&lt;class &#39;int&#39;&gt; : 2</code></p><ul><li><p>float 浮点型 小数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(type(<span class="number">3.14</span>),<span class="string">':'</span>,<span class="number">3.14</span>)</span><br></pre></td></tr></table></figure><p>输出：<code>&lt;class &#39;float&#39;&gt; : 3.14</code></p></li></ul><ul><li><p>complex 复数 </p><p><em>形如$a+bj$的数据</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(type(<span class="number">3</span>+<span class="number">4j</span>),<span class="string">':'</span>,<span class="number">3</span>+<span class="number">4j</span>)</span><br></pre></td></tr></table></figure></li></ul><p>  输出：<code>&lt;class &#39;complex&#39;&gt; : (3+4j)</code></p><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 String"></a><strong>字符串 String</strong></h3><p>由一串字符组成（数字、字母、空格以及其他字符）</p><p>用<code>&quot; &quot;</code>或<code>&#39; &#39;</code>包围</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(type(<span class="string">'python nb'</span>),<span class="string">':'</span>,<span class="string">'python nb'</span>)</span><br><span class="line">print(type(<span class="string">"python nb"</span>),<span class="string">':'</span>,<span class="string">"python nb"</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#39;str&#39;&gt; : python nb</span><br><span class="line">&lt;class &#39;str&#39;&gt; : python nb</span><br></pre></td></tr></table></figure><h3 id="布尔-Boolean"><a href="#布尔-Boolean" class="headerlink" title="布尔 Boolean"></a><strong>布尔 Boolean</strong></h3><p>取值：True、False</p><p>用于逻辑运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(type(<span class="literal">True</span>),<span class="string">':'</span>,<span class="literal">True</span>)</span><br><span class="line">print(<span class="number">2</span>&gt;<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#39;bool&#39;&gt; : True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p><strong>注：python严格区分大小写，True与False第一位均为大写！</strong></p><h4 id="真值测试"><a href="#真值测试" class="headerlink" title="真值测试"></a>真值测试</h4><blockquote><p><strong>&nbsp;&nbsp;注意啦！！！！！！！！！！！！！！！！！！<br>这里着重强调！！python的真值判断！！！！与众不同！！！<br>首先说在python中，万物皆可Boolean！！！！<br>这句话的意思是，无论是python的内置对象还是自定义类的对象都可转换成Booelan值，也就是说，都有对应的真值！！！！！！！</strong></p></blockquote><p><strong>python 官方文档镇楼！！！！！！！！！！！！！！！！！</strong></p><blockquote><h2 id="Truth-Value-Testing"><a href="#Truth-Value-Testing" class="headerlink" title="Truth Value Testing"></a>Truth Value Testing</h2><p>Any object can be tested for truth value, for use in an <a href="https://docs.python.org/3/reference/compound_stmts.html#if" target="_blank" rel="noopener"><code>if</code></a> or <a href="https://docs.python.org/3/reference/compound_stmts.html#while" target="_blank" rel="noopener"><code>while</code></a> condition or as operand of the Boolean operations below.</p><p>By default, an object is considered true unless its class defines either a <a href="https://docs.python.org/3/reference/datamodel.html#object.__bool__" target="_blank" rel="noopener"><code>__bool__()</code></a> method that returns <code>False</code> or a <a href="https://docs.python.org/3/reference/datamodel.html#object.__len__" target="_blank" rel="noopener"><code>__len__()</code></a> method that returns zero, when called with the object. <a href="https://docs.python.org/3/library/stdtypes.html?highlight=boolean#id12" target="_blank" rel="noopener">1</a> Here are most of the built-in objects considered false:</p><blockquote></blockquote><ul><li>constants defined to be false: <code>None</code> and <code>False</code>.</li><li>zero of any numeric type: <code>0</code>, <code>0.0</code>, <code>0j</code>, <code>Decimal(0)</code>, <code>Fraction(0, 1)</code></li><li>empty sequences and collections: <code>&#39;&#39;</code>, <code>()</code>, <code>[]</code>, <code>{}</code>, <code>set()</code>, <code>range(0)</code></li></ul><p>Operations and built-in functions that have a Boolean result always return <code>0</code> or <code>False</code> for false and <code>1</code> or <code>True</code> for true, unless otherwise stated. (Important exception: the Boolean operations <code>or</code> and <code>and</code> always return one of their operands.)</p></blockquote><p>看不懂木得关系，我给大家解释一下：</p><p>​        <strong>他就是说，python中所有的对象都有真值，都能放在<code>if</code>或<code>while</code>语句中</strong></p><p>​        <strong>然而，他们的真值是怎么来的呢？原来python类中有这么两个魔术方法（魔术方法我个人感觉类似于java中的<code>toString()</code>方法，就是会隐式调用）——一个是返回布尔类型的<code>__bool__()</code>方法，一个呢是返回整形的<code>_len_()</code>方法（很显然，返回长度！）；那么就是靠这两个方法，只需要看他们的返回值就能决定对象的真值（返回<code>0</code> 或<code>False</code>假，<code>1</code>或<code>True</code>为真）</strong></p><p>​        <strong>还有除了一下几种为Fasle的情况，剩下的都为True:</strong></p><ul><li><strong>定义为false的常量：<code>None</code>和<code>False</code>。</strong></li><li><strong>任何为零的数值类型：<code>0</code>，<code>0.0</code>，<code>0j</code>，<code>Decimal(0)</code>， <code>Fraction(0, 1)</code></strong></li><li><strong>空序列和集合：<code>&#39;&#39;</code>，<code>()</code>，<code>[]</code>，<code>{}</code>，<code>set()</code>， <code>range(0)</code></strong></li></ul><p><strong>稍微总结一下就是：非假即真！一切与0有关的都为假（比如数值0，长度为0）</strong></p><p><strong>两个魔术方法的官方文档再次镇楼！！！！！！！！</strong></p><blockquote><p><code>object.``__bool__</code>(<em>self</em>)</p><p>Called to implement truth value testing and the built-in operation <code>bool()</code>; should return <code>False</code> or <code>True</code>. When this method is not defined, <code>__len__()</code> is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither <code>__len__()</code> nor <code>__bool__()</code>, all its instances are considered true.</p><p><br><code>object.``__len__</code>(<em>self</em>)</p><p>Called to implement the built-in function <a href="https://docs.python.org/3/library/functions.html#len" target="_blank" rel="noopener"><code>len()</code></a>. Should return the length of the object, an integer <code>&gt;=</code> 0. Also, an object that doesn’t define a <code>__bool__()</code> method and whose <code>__len__()</code> method returns zero is considered to be false in a Boolean context.</p><p><strong>CPython implementation detail:</strong> In CPython, the length is required to be at most <a href="https://docs.python.org/3/library/sys.html#sys.maxsize" target="_blank" rel="noopener"><code>sys.maxsize</code></a>. If the length is larger than <code>sys.maxsize</code> some features (such as <a href="https://docs.python.org/3/library/functions.html#len" target="_blank" rel="noopener"><code>len()</code></a>) may raise <a href="https://docs.python.org/3/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a>. To prevent raising <code>OverflowError</code> by truth value testing, an object must define a <code>__bool__()</code> method.</p></blockquote><h3 id="列表-List"><a href="#列表-List" class="headerlink" title="列表 List"></a><strong>列表 List</strong></h3><ul><li><strong>序列类型（可迭代，序列表示索引为非负整数的有序对象集合，字符串也算序列，上面忘说了，嘤嘤嘤）</strong></li><li><strong>可变序列</strong></li><li><strong><code>[data, data, data,...]</code></strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">a[<span class="number">0</span>]</span><br><span class="line">c = [<span class="number">1</span>, <span class="string">'a'</span>, <span class="literal">True</span>, <span class="number">1.0</span>]</span><br><span class="line">print(c[<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a><strong>元组 Tuple</strong></h3><ul><li><strong>序列类型</strong></li><li><strong>不可变系列（元素不支持修改）</strong></li><li><strong><code>(data, data, data,...)</code></strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">print(b[<span class="number">0</span>])</span><br><span class="line">c = (<span class="number">1</span>, <span class="string">'a'</span>, <span class="literal">True</span>, <span class="number">1.0</span>)</span><br><span class="line">print(c[<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="字典-Dictionary"><a href="#字典-Dictionary" class="headerlink" title="字典 Dictionary"></a><strong>字典 Dictionary</strong></h3><ul><li><strong>映射类型(key-value,“键”-“值”对，类似于java的HashMap)</strong></li><li><strong><code>{key1: value1, key2: vaule2,...}</code></strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">son = &#123;<span class="number">201701</span>: <span class="string">'小黑'</span>, <span class="number">201702</span>: <span class="string">'小强'</span>&#125;</span><br><span class="line">print(son[<span class="number">201701</span>])</span><br><span class="line">dic = &#123;<span class="number">1001</span>: <span class="string">'小黑'</span>, <span class="number">1002</span>: <span class="literal">True</span>, <span class="string">"错误"</span>: <span class="literal">False</span>&#125;</span><br><span class="line">print(dic[<span class="string">"错误"</span>])</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小黑</span><br><span class="line">False</span><br></pre></td></tr></table></figure><h3 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合 Set"></a><strong>集合 Set</strong></h3><ul><li><strong>无序，元素不充分(类似于java的Set)</strong></li><li><code>{data1, data2, data3,...}</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="string">'小明'</span>, <span class="string">'小红'</span>, <span class="string">'小明'</span>, <span class="number">192</span>, <span class="number">198.1</span>, <span class="number">192</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>&#125;</span><br><span class="line">print(s)</span><br><span class="line">print(s[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;192, True, False, &#39;小明&#39;, 198.1, &#39;小红&#39;&#125;</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-43-7d2aee10af49&gt; in &lt;module&gt;()</span><br><span class="line">      1 s &#x3D; &#123;&#39;小明&#39;, &#39;小红&#39;, &#39;小明&#39;, 192, 198.1, 192, True, False, False&#125;</span><br><span class="line">      2 print(s)</span><br><span class="line">----&gt; 3 print(s[0])</span><br><span class="line"></span><br><span class="line">TypeError: &#39;set&#39; object does not support indexing</span><br></pre></td></tr></table></figure><h2 id="变量-Variables"><a href="#变量-Variables" class="headerlink" title="变量 Variables"></a>变量 Variables</h2><p>与其他语言基本一致，就是不需要声明类型，直接赋值，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>而且python中不存在<code>x++</code>操作，应使用<code>x += 1</code></p><p><strong>还有就是python中存在打包赋值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x, y = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">print(x, y)</span><br><span class="line">x, y = y, x</span><br><span class="line">print(x, y)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure><p>另外命名最好符合规范，增加代码可读性，像：</p><ul><li>不能数字开头</li><li>不能出现空格</li><li>不能与python保留字相同。</li></ul><p>比较好的命名规范：</p><ul><li>变量名由多个单词组成，单词之间用_连接</li><li>类目多个单词，每个单词首字母大写</li><li>常量所有首字母大写</li></ul><p>附：<a href="https://wiki.shileizcc.com/confluence/pages/viewpage.action?pageId=42533077" target="_blank" rel="noopener">python保留字</a></p><h1 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h1><ul><li><p>顺序（不讲！任性）</p></li><li><p><strong>循环</strong></p><ol><li><p>遍历：</p><p><code>for</code>  元素  <code>in</code>  可迭代对象：</p><p>​        语句</p><p>顺便说一下<code>for i in range(3)</code>相当于<code>for (int i = 0; i &lt; 3&#39; i++)</code></p><p><code>for i in range(1, 5)</code>相当于<code>for (int i = 1; i &lt; 5; i ++)</code></p></li><li><p>while</p><p><code>while</code>  条件：</p><p>​        语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]:    <span class="comment"># 每次迭代，取出一个i</span></span><br><span class="line">    res += i               <span class="comment"># 对每次迭代取出的i 进行相应操作   </span></span><br><span class="line">print(res)                      <span class="comment"># 遍历结束后，执行后续语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> res&gt;<span class="number">8</span>:</span><br><span class="line">    res -= <span class="number">1</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15</span><br><span class="line">8</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>分支</strong></p><p>if   条件：</p><p>​    条件为真，执行</p><p>else :</p><p>​     条件为假，执行</p><p>或者</p><p>if   条件1：</p><p>​    条件1为真，执行</p><p>elif  条件2:</p><p>​     条件1为假的条件下，条件2为真，执行</p><p>else:</p><p>​     上述条件都为假，执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">money = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> money &lt; <span class="number">10</span>:</span><br><span class="line">    print(<span class="string">'买的起'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'买不起'</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> money &lt; <span class="number">10</span>:</span><br><span class="line">    print(<span class="string">'买的起'</span>)</span><br><span class="line"><span class="keyword">elif</span> money &lt;= <span class="number">15</span>:</span><br><span class="line">    print(<span class="string">'用花呗'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'彻底买不起'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">买不起</span><br><span class="line">用花呗</span><br></pre></td></tr></table></figure></li></ul><h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><ul><li><p><code>input()</code>：动态交互输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; input(&quot;请输入一个数字：&quot;)</span><br><span class="line">print(x)</span><br><span class="line">print(type(x))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请输入一个数字：4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">&lt;class &#39;str&#39;&gt;</span><br></pre></td></tr></table></figure><p>可以看出，<code>input()</code>方法返回的是字符串。也就是说，无论我们输入的什么都会被当做字符串处理</p></li><li><p><code>eval()</code></p><p>上面说到<code>input()</code>方法返回的是字符串,那么我们要输入数值类型怎么办，就用<code>eval()</code>去除引号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = eval(input(<span class="string">"请输入一个数字："</span>))</span><br><span class="line">print(y)</span><br><span class="line">print(type(y))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入一个数字：4</span><br><span class="line">4</span><br><span class="line">&lt;class &#39;int&#39;&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>print()</code>：打印输出</p><p>相当于<code>java</code>的<code>System.out,println()</code>,默认自动换行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>若不向自动换行，则用换行控制<code>end =</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">        print(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(i, end = <span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'hahaha'</span>,end = <span class="string">' 你哈哈个锤子 '</span>)</span><br><span class="line">print(<span class="string">'嘤嘤嘤'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">hahaha 你哈哈个锤子 嘤嘤嘤</span><br></pre></td></tr></table></figure></li><li><p><code>format()</code>：格式化输出方法</p><p>“字符{0: 修饰}字符{1: 修饰}字符.format(v0,v1)”</p><p>可以没有修饰，没有修饰就是将后面的参数填入前面对应的大括号内，v0填进0，v1填进1，如果大括号内没有内容，则默认顺序为0123。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;四是&#123;0&#125;,10是&#123;1&#125;&quot;.format(4, &#39;十&#39;)</span><br></pre></td></tr></table></figure><p>Out[61]:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;四是4,10是十&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;14是&#123;&#125;,四十是&#123;&#125;&quot;.format(&#39;十四&#39;, 40)</span><br></pre></td></tr></table></figure><p>Out[63]:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;14是十四,四十是40&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;不要把14说成&#123;1&#125;,也不要把四十说成&#123;0&#125;&quot;.format(&#39;十四&#39;, 40)</span><br></pre></td></tr></table></figure><p>Out[63]:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;不要把14说成40,也不要把四十说成十四&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&quot;四是&#123;0&#125;,10不是&#123;0&#125;&quot;.format(4, &#39;十&#39;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;14是&#123;&#125;,四十是&#123;&#125;&quot;.format(&#39;十四&#39;, 40)</span><br></pre></td></tr></table></figure><p>Out[63]:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;14是十四,四十是40&#39;</span><br></pre></td></tr></table></figure><p>带修饰的：</p><p>修饰符优先级，越往上优先级越高：</p><ol><li>引导符号 ：</li><li>填充：用于填充的字符如* __等</li><li>对齐：&lt;左对齐，&lt;右对齐，^居中对齐</li><li>宽度：设定输出的宽度 </li><li>数字千分位分隔符：数字千分位分隔符适用于整数和浮点数  ,</li><li>.精度：浮点数：小数部分精度<pre><code>          字符串：最大输出长度</code></pre></li><li>类型：整数类型：b,c,d,o,x,X<pre><code>         浮点类型：e,E,f,%</code></pre></li></ol><p>上案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 填充</span><br><span class="line">print(&quot;&#123;0:_^20&#125;&quot;.format(&#39;test&#39;))</span><br><span class="line">输出 -&gt; ________test________</span><br><span class="line">print(&quot;&#123;0:*&lt;30&#125;&quot;.format(&#39;test&#39;))</span><br><span class="line">输出 -&gt; test**************************</span><br><span class="line"></span><br><span class="line"># 数字千分位符</span><br><span class="line">print(&quot;&#123;0:,&#125;&quot;.format(10000000))</span><br><span class="line">输出 -&gt; 10,000,000</span><br><span class="line"></span><br><span class="line"># 精度</span><br><span class="line">print(&quot;&#123;0:.3f&#125;&quot;.format(3.1415926))</span><br><span class="line">输出 -&gt; 3.142</span><br><span class="line"></span><br><span class="line"># 百分数</span><br><span class="line">print(&quot;&#123;0:.1%&#125;&quot;.format(0.818727))</span><br><span class="line">输出 -&gt; 81.9%</span><br><span class="line"></span><br><span class="line"># 科学计数法</span><br><span class="line">print(&quot;&#123;0:.2e&#125;&quot;.format(0.818727))</span><br><span class="line">输出 -&gt; 8.19e-01</span><br><span class="line"></span><br><span class="line"># 类型</span><br><span class="line">print(&quot;二进制 &#123;0:b&#125;,Unicode码 &#123;0:c&#125;,十进制 &#123;0:d&#125;,八进制 &#123;0:o&#125;,十六进制 &#123;0:x&#125;&quot;.format(250))</span><br><span class="line">输出 -&gt; 二进制 11111010,Unicode码 ú,十进制 250,八进制 372,十六进制 fa</span><br></pre></td></tr></table></figure></li></ul><ul><li>I/O 太累了，不写了，以后再说吧</li></ul><h1 id="PEP-8编码规范"><a href="#PEP-8编码规范" class="headerlink" title="PEP 8编码规范"></a>PEP 8编码规范</h1><p><strong>话不多说，上链接：</strong></p><p><a href="https://alvinzhu.xyz/2017/10/07/python-pep-8/" target="_blank" rel="noopener">Python PEP-8编码风格指南中文版</a></p><p><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP 8 — Style Guide for Python Code</a></p><p><strong>给大家象征性的总结一下：</strong></p><p>编码规范是为了增加代码可读性，但不要保持盲目，具体情况具体分析。</p><p>代码的布局靠缩进，4个字符，也就是一个Tab键（用空格缩进的代码是在蓝翔学的吗）</p><p>每行最大长度在79个字符之内，要不看不过来，太长了。</p><p>二元运算符前后有空格，并且前或后换行（看自己项目规定），逗号后有空格，混合运算低优先级有空格。</p><p>空行分隔函数（2）和类（2）还有方法（1）</p><p>UTF-8</p><p>要有注释</p><p>要有注解</p><p>注释分两种</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这叫单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">这叫多行注释</span></span><br><span class="line"><span class="string">啊！</span></span><br><span class="line"><span class="string">大海啊！</span></span><br><span class="line"><span class="string">你都是水！</span></span><br><span class="line"><span class="string">太累了！</span></span><br><span class="line"><span class="string">告辞！</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python数据分析基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python求矩阵的逆</title>
      <link href="/title.html"/>
      <url>/title.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍了矩阵的逆定义，并用python实现求矩阵的逆。同时讲到了代数余子式、伴随矩阵。并用python语言实现。其实在numpy中有求矩阵的逆的函数，而本文则是介绍矩阵的逆，并编程自己实现来提高自己的编程水平</p><a id="more"></a><h1 id="准备工作-Ready-to-work"><a href="#准备工作-Ready-to-work" class="headerlink" title="准备工作 Ready to work"></a>准备工作 Ready to work</h1><h2 id="环境-Environment"><a href="#环境-Environment" class="headerlink" title="环境 Environment"></a>环境 Environment</h2><p><strong>Anaconda 3 + Python 3.6.5 +  Jupyter</strong></p><h2 id="模块导入-Module-import"><a href="#模块导入-Module-import" class="headerlink" title="模块导入 Module import"></a>模块导入 Module import</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv</span><br></pre></td></tr></table></figure><h1 id="代数余子式-Algebraic-cofactor"><a href="#代数余子式-Algebraic-cofactor" class="headerlink" title="代数余子式 Algebraic cofactor"></a>代数余子式 Algebraic cofactor</h1><h2 id="定义-Definition"><a href="#定义-Definition" class="headerlink" title="定义 Definition"></a>定义 Definition</h2><ul><li><p><strong>定义：在n阶行列式，把$\;(i,j)\;$元$\;a_{ij}\;$所在的第i行和第j列划去后，留下来的n-1阶行列式叫做$\;(i,j)\;$元$\;a_{ij}\;$的余子式，记作$\;M_{ij}\;$</strong></p></li><li><p><strong>$\bf A_{ij} = (-1)^{i+j}M_{ij}\;$叫做$\;(i,j)\;$元$\;a_{ij}\;$的代数余子式</strong></p></li></ul><script type="math/tex; mode=display">\bf D = \begin{vmatrix}{a_{11}} & {a_{12}} & {\cdots} & {a_{1j}}  & {\cdots} & {a_{1n}}\\{a_{21}} & {a_{22}} & {\cdots} & {a_{2j}}  & {\cdots} & {a_{2n}}\\\vdots&\vdots&&\vdots&&\vdots\\{a_{i1}} & {a_{i2}} & {\cdots} & {a_{ij}}  & {\cdots} & {a_{i-1n}}\\\vdots&\vdots&&\vdots&&\vdots\\{a_{m1}} & {a_{m2}} & {\cdots} & {a_{mj}}  & {\cdots} & {a_{mn}}\\\end{vmatrix}</script><ul><li>$\bf D$中$\;(i,j)\;$元$\;\bf a_{ij}\;$的余子式和代数余子式分别为：</li></ul><script type="math/tex; mode=display">\bf M_{ij} = \begin{vmatrix}{a_{11}} & {a_{12}} & {\cdots} & {a_{1\;j-1}} & {a_{i\;j+1}} & {\cdots} & {a_{1n}}\\{a_{21}} & {a_{22}} & {\cdots} & {a_{2\;j-1}} & {a_{2\;j+1}} & {\cdots} & {a_{2n}}\\\vdots&\vdots&&\vdots&\vdots&&\vdots\\{a_{i-1\;1}} & {a_{i-1\;2}} & {\cdots} & {a_{i-1\;j-1}} & {a_{i-1\;j+1}} & {\cdots} & {a_{i-1n}}\\{a_{i+1\;1}} & {a_{i+1\;2}} & {\cdots} & {a_{i+1\;j-1}} & {a_{i+1\;j+1}} & {\cdots} & {a_{i+1n}}\\\vdots&\vdots&&\vdots&\vdots&&\vdots\\{a_{m1}} & {a_{m2}} & {\cdots} & {a_{m\;j-1}} & {a_{m\;j+1}} & {\cdots} & {a_{mn}}\\\end{vmatrix}\;\;\;\;A_{ij} = (-1)^{i+j}M_{ij}</script><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现 Code"></a>代码实现 Code</h2><h3 id="余子式-Cofactor"><a href="#余子式-Cofactor" class="headerlink" title="余子式 Cofactor"></a>余子式 Cofactor</h3><table><tr><td bgcolor=FFFFEE><font face="楷体">    先求出给定矩阵的余子式，即去除指定的行和列，然后根据公式求出代数余子式。<center>提供两种实现思路</center></font></td></tr></table><ul><li>通过遍历实现，但不遍历整个矩阵。</li></ul><blockquote><p>变量说明:</p><ol><li>M：原始矩阵</li><li>index：指定元素的索引，长度为2的向量</li><li>temp：M中的每个行向量</li><li>det()：求行列式的函数</li></ol><p>思路：</p><ol><li><p>创建一个n-1阶的方阵（result）用于存放最后结果</p></li><li><p>通过遍历向result中按行赋值：</p><ul><li><p>先判断是否为要消去的一行，如果是跳过本次循环</p></li><li><p>遍历原矩阵并取出其中的行向量</p></li><li>将行向量切片，以index[0]为界限且不包含index[0]</li><li>将两个一位矩阵片段拼接并对应放入result中</li><li>返回result行列式的值</li></ul></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cof</span><span class="params">(M,index)</span>:</span></span><br><span class="line">    result = np.zeros((M.shape[<span class="number">0</span>]<span class="number">-1</span>,M.shape[<span class="number">1</span>]<span class="number">-1</span>))  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M.shape[<span class="number">0</span>]):</span><br><span class="line">        temp = copy.deepcopy(M[i])</span><br><span class="line">        <span class="keyword">if</span> i==index[<span class="number">0</span>]<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= index[<span class="number">0</span>]:</span><br><span class="line">            Ri = i<span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Ri = i</span><br><span class="line">        result[Ri] = np.append(temp[:index[<span class="number">1</span>]<span class="number">-1</span>],temp[index[<span class="number">1</span>]:])</span><br><span class="line">    <span class="keyword">return</span> det(result)</span><br></pre></td></tr></table></figure><ul><li>通过numpy自带方法对矩阵进行重组</li></ul><blockquote><ol><li>首先按照index的两个值作为x、y轴，对矩阵进行切片，将原始矩阵分为左上、右上、左下、右下四个矩阵</li><li>利用numpy.concatenate()函数对四个矩阵进行拼接：<ul><li>numpy.concatenate()有两个参数，第一个参数是矩阵列表，是要拼接的矩阵；第二个参数axis，axis=1表示对应行的数组进行拼接，axis=0表示对对应列进行拼接，默认为0</li><li>首先将左上、右上两个矩阵按行拼接组成结果矩阵的上半部分</li><li>同理求出结果矩阵的下半部分</li><li>最后将result的上下两部分按列拼接，返回result的行列式的值</li></ul></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cof1</span><span class="params">(M,index)</span>:</span></span><br><span class="line">    zs = M[:index[<span class="number">0</span>]<span class="number">-1</span>,:index[<span class="number">1</span>]<span class="number">-1</span>]</span><br><span class="line">    ys = M[:index[<span class="number">0</span>]<span class="number">-1</span>,index[<span class="number">1</span>]:]</span><br><span class="line">    zx = M[index[<span class="number">0</span>]:,:index[<span class="number">1</span>]<span class="number">-1</span>]</span><br><span class="line">    yx = M[index[<span class="number">0</span>]:,index[<span class="number">1</span>]:]</span><br><span class="line">    s = np.concatenate((zs,ys),axis=<span class="number">1</span>)</span><br><span class="line">    x = np.concatenate((zx,yx),axis=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> det(np.concatenate((s,x),axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure><h3 id="代数余子式-Algebraic-cofactor-1"><a href="#代数余子式-Algebraic-cofactor-1" class="headerlink" title="代数余子式 Algebraic cofactor"></a>代数余子式 Algebraic cofactor</h3><ul><li>参考公式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alcof</span><span class="params">(M,index)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> pow(<span class="number">-1</span>,index[<span class="number">0</span>]+index[<span class="number">1</span>])*cof(M,index)</span><br></pre></td></tr></table></figure><h1 id="伴随矩阵-Adjoint-matrix"><a href="#伴随矩阵-Adjoint-matrix" class="headerlink" title="伴随矩阵 Adjoint matrix"></a>伴随矩阵 Adjoint matrix</h1><h2 id="定义-Definition-1"><a href="#定义-Definition-1" class="headerlink" title="定义 Definition"></a>定义 Definition</h2><ul><li><strong>定义：行列式$\; \begin{vmatrix} A \end{vmatrix}\;$的各个元素的代数余子式$\;A_{ij}\;$构成的矩阵。</strong></li></ul><script type="math/tex; mode=display">adj(\bf C) = \begin{bmatrix}A_{11} & A_{21} & \cdots & A_{n1}\\A_{12} & A_{22} & \cdots & A_{n2}\\\vdots & \vdots && \vdots\\A_{1n} & A_{2n} & \cdots & A_{nn}\\\end{bmatrix} \;\;\;\;\;\;\;\;\;\;\;A_{ij}是C_{ij}的代数余子式</script><p>称为C的伴随矩阵，简称伴随阵，记作$C^*$</p><blockquote><p>伴随矩阵满足：</p><ul><li><script type="math/tex; mode=display">AA^* = A*A = \begin{vmatrix}A\end{vmatrix}E</script></li></ul></blockquote><h2 id="代码实现-Code-1"><a href="#代码实现-Code-1" class="headerlink" title="代码实现 Code"></a>代码实现 Code</h2><ul><li>分析公式可以看出伴随矩阵的形状与原始矩阵相同，伴随矩阵(i,j)位置上的元是原始矩阵(j,i)位置上元的代数余子式</li></ul><blockquote><p>思路：</p><ol><li>创建一个与原始矩阵形状相同的矩阵result</li><li>通过向result中填充数据</li></ol></blockquote><ul><li><strong>注：矩阵下标从1开始，而在代码中索引均从0开始</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adj</span><span class="params">(M)</span>:</span></span><br><span class="line">    result = np.zeros((M.shape[<span class="number">0</span>],M.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,M.shape[<span class="number">0</span>]+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,M.shape[<span class="number">1</span>]+<span class="number">1</span>):</span><br><span class="line">            result[j<span class="number">-1</span>][i<span class="number">-1</span>] = alcof(copy.deepcopy(M),[i,j])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="矩阵的逆-Inverse-of-matrix"><a href="#矩阵的逆-Inverse-of-matrix" class="headerlink" title="矩阵的逆 Inverse of matrix"></a>矩阵的逆 Inverse of matrix</h1><h2 id="定义-Definition-2"><a href="#定义-Definition-2" class="headerlink" title="定义 Definition"></a>定义 Definition</h2><ul><li><strong>定义：对于n阶矩阵A，如果有一个n阶矩阵B使其满足以下条件，则说矩阵A是可逆的，B是A的逆矩阵，简称逆阵。</strong></li></ul><script type="math/tex; mode=display">\bf AB=BA=E</script><ul><li><p><strong>A的逆记作$\bf A^{-1}$</strong></p></li><li><p><strong>定理1：若矩阵A可逆，则$\bf \begin{vmatrix} A\end{vmatrix} \neq 0$</strong></p></li><li><p><strong>定理2：若$\bf \begin{vmatrix} A\end{vmatrix} \neq 0$，则A可逆，且：</strong></p></li></ul><script type="math/tex; mode=display">\bf A^{-1} = \frac{1}{\begin{vmatrix} A \end{vmatrix}}A^*</script><ul><li><strong>推论：若$\bf AB=E($或$\bf BA=E)$，则$\bf B=A^*$</strong></li></ul><h2 id="代码实现-Code-2"><a href="#代码实现-Code-2" class="headerlink" title="代码实现 Code"></a>代码实现 Code</h2><ul><li>根据公式原始矩阵对应行列式的值的倒数乘该矩阵的伴随矩阵</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invmat</span><span class="params">(M)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> det(M)!=<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/det(M)*adj(M)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(原始矩阵不能为<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h1 id="测试-程序-Test-program"><a href="#测试-程序-Test-program" class="headerlink" title="测试 程序 Test program"></a>测试 程序 Test program</h1><ul><li>可以调用numpy.linalg.inv()函数来求得原始矩阵的逆，然后调用自己的函数，看两个输出结果是否相同</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv</span><br><span class="line">M = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line">print(inv(M))</span><br><span class="line">print(invmat(M))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 线性代数 </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实现基本的矩阵运算</title>
      <link href="/title.html"/>
      <url>/title.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍了矩阵的定义以及基本运算，并用python实现矩阵的运算。线性代数是机器学习的数学基础，而矩阵则是线代的基本，本文按照从理论知识到代码实践的思路，给大家讲解矩阵，并运用到编程中。</p><a id="more"></a><blockquote><p>首先声明矩阵的构建运算均在numpy模块中由相应的函数，而本文的目的主要是因为闲的无聊</p></blockquote><h1 id="矩阵及其运算"><a href="#矩阵及其运算" class="headerlink" title="矩阵及其运算"></a>矩阵及其运算</h1><h2 id="什么是矩阵？"><a href="#什么是矩阵？" class="headerlink" title="什么是矩阵？"></a>什么是矩阵？</h2><ul><li><strong>由$m{\times}n$个&emsp; $a_{ij}$(i=1,2,${\cdots}$,m;j=1,2,${\cdots}$,n)&emsp;数排列成的m行n列的数表</strong></li></ul><script type="math/tex; mode=display">A=\begin{bmatrix}{a_{11} } & {a_{12} } & {\cdots} & {a_{1n} }\\{a_{21} } & {a_{22} } & {\cdots} & {a_{2n} }\\{\vdots} & {\vdots} & {\ddots} & {\vdots}\\{a_{m1} } & {a_{m2} } & {\cdots} & {a_{mn} }\\\end{bmatrix}记作{A_{m*n} }</script><table><tr><td bgcolor=FFFFEE><font face="楷体">    这m×n个数称为矩阵A的<font face="楷体" color=#ff2222>    元素（元）</font></font></td></tr></table><h2 id="矩阵基本运算"><a href="#矩阵基本运算" class="headerlink" title="矩阵基本运算"></a>矩阵基本运算</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><ul><li>两个$m{\times}n$的矩阵相加，即对应元素相加</li></ul><script type="math/tex; mode=display">\begin{bmatrix}{a_{11}} & {a_{12}} & {\cdots} & {a_{1n}}\\ {a_{21}} & {a_{22}} & {\cdots} & {a_{2n}}\\{\vdots} & {\vdots} & {\ddots} & {\vdots}\\{a_{m1}} & {a_{m2}} & {\cdots} & {a_{mn}}\\\end{bmatrix}+\begin{bmatrix}{b_{11}} & {b_{12}} & {\cdots} & {b_{1n}}\\ {b_{21}} & {b_{22}} & {\cdots} & {b_{2n}}\\{\vdots} & {\vdots} & {\ddots} & {\vdots}\\{b_{m1}} & {b_{m2}} & {\cdots} & {b_{mn}}\\\end{bmatrix}=\begin{bmatrix}{a_{11}+b_{11}} & {a_{12}+b_{12}} & {\cdots} & {a_{1n}+b_{1n}}\\ {a_{21}+b_{21}} & {a_{22}+b_{22}} & {\cdots} & {a_{2n}+b_{2n}}\\{\vdots} & {\vdots} & {\ddots} & {\vdots}\\{a_{m1}+b_{m1}} & {a_{m2}+b_{m2}} & {\cdots} & {a_{mn}+b_{mn}}\\\end{bmatrix}\label{eq:jiafa}</script><blockquote><p>加法满足：</p><ol><li>$A + B = B + A$ (交换律)</li><li>$(A + B) + C = A + (B + C)$  （结合律）</li></ol></blockquote><h3 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h3><ul><li>数$\lambda$与矩阵$A$的乘积记作$\lambda A$或$A \lambda$</li></ul><script type="math/tex; mode=display">\lambda A = A \lambda=\begin{bmatrix}{\lambda a_{11}} & {\lambda a_{12}} & {\cdots} & {\lambda a_{1n}}\\{\lambda a_{21}} & {\lambda a_{22}} & {\cdots} & {\lambda a_{2n}}\\{\vdots} & {\vdots} & {\ddots} & {\vdots}\\{\lambda a_{m1}} & {\lambda a_{m2}} & {\cdots} & {\lambda a_{mn}}\\\end{bmatrix}\label{eq:shucheng}</script><blockquote><p>数乘满足：</p><ol><li>$(\lambda \mu)A = \lambda (\mu A)$&emsp;<strong>$\lambda \mu$为常数</strong></li><li>$(\lambda \mu)A = \lambda A + \mu A$</li><li>$\lambda (A+B) = \lambda A + \lambda B$</li></ol></blockquote><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><h4 id="Hadamard乘积"><a href="#Hadamard乘积" class="headerlink" title="Hadamard乘积"></a>Hadamard乘积</h4><ul><li>两个同型矩阵中对应元素乘积，记作$A\bigodot B$</li></ul><script type="math/tex; mode=display">\begin{bmatrix}{a_{11}} & {a_{12}} & {\cdots} & {a_{1n}}\\ {a_{21}} & {a_{22}} & {\cdots} & {a_{2n}}\\{\vdots} & {\vdots} & {\ddots} & {\vdots}\\{a_{m1}} & {a_{m2}} & {\cdots} & {a_{mn}}\\\end{bmatrix}+\begin{bmatrix}{b_{11}} & {b_{12}} & {\cdots} & {b_{1n}}\\ {b_{21}} & {b_{22}} & {\cdots} & {b_{2n}}\\{\vdots} & {\vdots} & {\ddots} & {\vdots}\\{b_{m1}} & {b_{m2}} & {\cdots} & {b_{mn}}\\\end{bmatrix}=\begin{bmatrix}{a_{11}{\times}b_{11}} & {a_{12}{\times}b_{12}} & {\cdots} & {a_{1n}{\times}b_{1n}}\\ {a_{21}{\times}b_{21}} & {a_{22}{\times}b_{22}} & {\cdots} & {a_{2n}{\times}b_{2n}}\\{\vdots} & {\vdots} & {\ddots} & {\vdots}\\{a_{m1}{\times}b_{m1}} & {a_{m2}{\times}b_{m2}} & {\cdots} & {a_{mn}{\times}b_{mn}}\\\end{bmatrix}\label{eq:had}</script><h4 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h4><ul><li>$A=(a_{ij})$是$m{\times}s$矩阵，$B=(b_{ij})$是$s{\times}n$矩阵<br/>规定矩阵$A$与矩阵$B$的乘积$m{\times}n$矩阵$C=(c_{ij})$,其中:<br/></li></ul><script type="math/tex; mode=display">\boxed{c_{ij} = a_{i1}b_{1j}+a_{i2}b_{2j}+{\cdots}+a_{is}b_{sj}\\\quad =\displaystyle \sum^{s}_{k=1}{a_{ik}b_{kj}}(i=1,2,{\cdots},m;j=1,2,{\cdots},n)}\label{eq:dianji}</script><blockquote><p>矩阵点积满足：</p><ol><li>$(AB)C=A(BC)$</li><li>$\lambda (AB) = (\lambda A)B = A(\lambda B)$</li><li>$A(B+C) = AB + AC  \;\;\;(B+C)A = BA + CA$</li><li><strong>$AB\neq BA$</strong></li></ol></blockquote><table><tr><td bgcolor=FFFFEE><font face="楷体" color=#ff2222 size=5><center>    矩阵相乘不满足交换律</center></font></td></tr></table><h1 id="python实现矩阵基本运算思路及代码"><a href="#python实现矩阵基本运算思路及代码" class="headerlink" title="python实现矩阵基本运算思路及代码"></a>python实现矩阵基本运算思路及代码</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p><strong>Anaconda 3 + Python 3.6.5 +  Jupyter</strong></p><h2 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="加法-1"><a href="#加法-1" class="headerlink" title="加法"></a>加法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>参考矩阵加法公式$\eqref{eq:jiafa}$</li></ul><blockquote><ol><li>先判断两矩阵能否相加</li><li>遍历两个矩阵</li><li>各相同位置元素相加</li></ol></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(a.shape != b.shape):</span><br><span class="line">        print(<span class="string">'两矩阵不为同型矩阵！'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    c = np.zeros(a.shape)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(a.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(a.shape[<span class="number">1</span>]):</span><br><span class="line">            c[i][j] = a[i][j] + b[i][j]</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure><h2 id="数乘-1"><a href="#数乘-1" class="headerlink" title="数乘"></a>数乘</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>参考矩阵数乘公式$\eqref{eq:shucheng}$</li></ul><blockquote><ol><li>遍历矩阵</li><li>相乘</li></ol></blockquote><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSub</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    c = np.zeros(a.shape)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(a.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(a.shape[<span class="number">1</span>]):</span><br><span class="line">            c[i][j] = a[i][j] * b</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure><h2 id="Hadamard乘积-1"><a href="#Hadamard乘积-1" class="headerlink" title="Hadamard乘积"></a>Hadamard乘积</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>参考Hadamard乘积公式$\eqref{eq:had}$</li></ul><blockquote><p>与矩阵加法思路一致</p></blockquote><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵对应元素相乘 Hadamard乘积</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">had</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(a.shape != b.shape):</span><br><span class="line">        print(<span class="string">'两矩阵不为同型矩阵！'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    c = np.zeros(a.shape)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(c.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(c.shape[<span class="number">1</span>]):</span><br><span class="line">            c[i][j] = a[i][j] * b[i][j]</span><br></pre></td></tr></table></figure><h2 id="点积-1"><a href="#点积-1" class="headerlink" title="点积"></a>点积</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul><li>参考矩阵点积公式$\eqref{eq:dianji}$</li></ul><blockquote><p>理解公式：乘积C的第m行第n列的元素等于矩阵A的第m行的元素与矩阵B的第n列对应元素乘积之和。</p><ol><li>判断两矩阵是否为同型矩阵</li><li>构建m行n列的结果矩阵</li><li>向结果矩阵中赋值:<br>(1). 遍历结果矩阵<br>(2). 求出矩阵A对应行与矩阵B对应列的元素乘积之和:<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据公式，A矩阵的行与B矩阵的列均确定，因此根据累加条件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遍历两个矩阵来确定另一个索引位置，并累加求和</li></ol></blockquote><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵相乘</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(a.shape[<span class="number">1</span>] != b.shape[<span class="number">0</span>]):</span><br><span class="line">        print(<span class="string">'两矩阵不能相乘'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    m = a.shape[<span class="number">0</span>]</span><br><span class="line">    n = b.shape[<span class="number">1</span>]</span><br><span class="line">    s = a.shape[<span class="number">1</span>]</span><br><span class="line">    c = np.zeros((m,n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(s):</span><br><span class="line">                c[i][j] += a[i][k]*b[k][j]</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 线性代数 </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实现克莱姆法则</title>
      <link href="/title.html"/>
      <url>/title.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍了克莱姆法则，并用pthon进行实现。克莱姆法则，又译克拉默法则（Cramer’s Rule）是线性代数中一个关于求解线性方程组的定理。它适用于变量和方程数目相等的线性方程组，对于多于两个或三个方程的系统，克莱姆的规则在计算上非常低效；与具有多项式时间复杂度的消除方法相比，其渐近的复杂度为O（n·n！）。</p><a id="more"></a><blockquote><p><strong>注：本文对numpy对象使用append方法时均使用了深拷贝deepcopy，因为python中对象的赋值是按引用传递的，如果不使用深拷贝在append时会改变原有对象从而覆盖原先的值</strong></p></blockquote><h1 id="首先完成python模拟行列式运算"><a href="#首先完成python模拟行列式运算" class="headerlink" title="首先完成python模拟行列式运算"></a>首先完成python模拟行列式运算</h1><script type="math/tex; mode=display">\begin{vmatrix}{a_{11}}&{a_{12}}&{\cdots}&{a_1n}\\{a_{21}}&{a_{22}}&{\cdots}&{a_2n}\\{\vdots}&{\vdots}&{\ddots}&{\vdots}\\{a_{n1}}&{a_{n2}}&{\cdots}&{a_{nn}}\\\end{vmatrix}= \sum{(-1)^{t}}{a_{1p_{1}}a_{2p_{2}}}{\cdots}{a_{np_{n}}}</script><blockquote><p>标注：t:&emsp;${p_1}{p_2}{p_3}{\cdots}{p_n}$ 的逆序数</p></blockquote><h2 id="公式分析"><a href="#公式分析" class="headerlink" title="公式分析"></a>公式分析</h2><p><strong>${p_1}{p_2}{p_3}{\cdots}{p_n}$从下标来看可以看作n个数的全排列，而t则是后面下标序列的逆序数，所以我们可以将他分成三个模块来实现，首先是求的我们所需的全排列序列，然后对该序列求逆序数，最后累加求和</strong></p><h2 id="模块分析与实现"><a href="#模块分析与实现" class="headerlink" title="模块分析与实现"></a>模块分析与实现</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p><strong>Anaconda 3 + Python 3.6.5 + Jupyter</strong></p><h3 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import copy</span><br></pre></td></tr></table></figure><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><ul><li><p>从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。</p><p>公式：全排列数f(n)=n!(定义0!=1)</p></li></ul><p><a href="https://ae01.alicdn.com/kf/Hc6b02e38d7fe46a78ff3a32959efbd823.png" target="_blank" rel="noopener"><img src="https://ae01.alicdn.com/kf/Hc6b02e38d7fe46a78ff3a32959efbd823.png" alt="https://ae01.alicdn.com/kf/Hc6b02e38d7fe46a78ff3a32959efbd823.png"></a></p><p>(深度优先搜索)采用递归的思路:先确定一个节点，然后后面的节点进行交换，在确定下一个节点，一层层递归，递归回溯时应将顺序交换回来，以便向其他子节点方向递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全排列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(n)</span>:</span></span><br><span class="line">    arr = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(n)]</span><br><span class="line">    result =[]</span><br><span class="line">    dfs(arr,<span class="number">0</span>,len(arr),result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(arr, begin, end,result)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> begin == end:</span><br><span class="line">        result.append(copy.deepcopy(arr))</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(begin,end):</span><br><span class="line">            arr[i],arr[begin] = arr[begin],arr[i]</span><br><span class="line">            dfs(arr,begin+<span class="number">1</span>,end,result)</span><br><span class="line">            arr[i],arr[begin] = arr[begin],arr[i]</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h3><ul><li>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个<strong>逆序</strong>。一个排列中逆序的总数就称为这个排列的<strong>逆序数</strong>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逆序数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverse</span><span class="params">(arr)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[i]:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">pass</span>    </span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="方阵计算"><a href="#方阵计算" class="headerlink" title="方阵计算"></a>方阵计算</h3><ul><li>根据公式进行累加计算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">det</span><span class="params">(matrix)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> matrix.shape[<span class="number">0</span>]!=matrix.shape[<span class="number">1</span>]:</span><br><span class="line">        print(<span class="string">'此矩阵不是方阵！'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    permutation = permutations(matrix.shape[<span class="number">0</span>])</span><br><span class="line">    permutation = np.array(permutation)</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(permutation)):</span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(matrix.shape[<span class="number">0</span>]):</span><br><span class="line">            a*=matrix[j][permutation[i][j]]</span><br><span class="line">        result += pow(<span class="number">-1</span>,inverse(permutation[i]))*a</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="克莱姆法则-Cramer’s-rule"><a href="#克莱姆法则-Cramer’s-rule" class="headerlink" title="克莱姆法则 Cramer’s rule"></a>克莱姆法则 <em>Cramer’s rule</em></h1><p><strong>对以下方程组：</strong></p><script type="math/tex; mode=display">\begin{cases}a_{11}x_1 + a_{12}x_2 + {\cdots} + a_{1n}x_n = b_1\\a_{21}x_1 + a_{22}x_2 + {\cdots} + a_{2n}x_n = b_2\\{\cdots}{\cdots}\\a_{n1}x_1 + a_{n2}x_2 + {\cdots} + a_{nn}x_n = b_n\\\end{cases}</script><p><strong><em><font color=red>如果线性方程组的系数行列式D不为零，即：</font></em></strong></p><script type="math/tex; mode=display">D=\begin{vmatrix}{a_{11}}&{\cdots}&{a_{1n}}\\{\vdots}&{\ddots}&{\vdots}\\{a_{n1}}&{\cdots}&{a_{nn}}\\\end{vmatrix} {\neq} 0</script><p><strong><em><font color=red>那么方程组有唯一解：</font></em></strong></p><script type="math/tex; mode=display">x_1 = \frac{D_1}{D} , x_2 = \frac{D_2}{D} , {\cdots} , x_n = \frac{D_n}{D}</script><p><strong><em><font color=red>其中&emsp;$D_j$(j=1,2,$\cdots$，n)&emsp;是把行列式D中第j列元素用方程组右端的常数项代替后所得到的n阶行列式，即：</font></em></strong></p><script type="math/tex; mode=display">D_j=\begin{vmatrix}{a_{11}}&{\cdots}&a_{1，j-1}&b_1&{\cdots}&a_{1n}\\{\vdots}&&{\vdots}&{\vdots}&&{\vdots}\\{a_{n1}}&{\cdots}&a_{n，j-1}&b_1&{\cdots}&a_{nn}\\\end{vmatrix}</script><blockquote><p><strong>对此我们做出如下约定：</strong></p><ol><li>d为系数矩阵作为函数的第一个参数</li><li>b为方程组右端常数项组成的列向量作为函数的第二个参数</li><li>d_i为公式中的&emsp;$D_j$(j=1,2,$\cdots$，n)&emsp;组成的三维矩阵</li><li>返回由结果&emsp;$x_i$(j=i,2,$\cdots$，n)&emsp;组成的向量</li></ol></blockquote><p><strong>实现代码：</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cramer</span><span class="params">(d,b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> d.shape[<span class="number">0</span>]!=d.shape[<span class="number">1</span>]:</span><br><span class="line">        print(<span class="string">'此矩阵不是方阵！'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> det(d) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'系数方阵为0'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    d_i = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(b.shape[<span class="number">0</span>]):</span><br><span class="line">        d_i.append(copy.deepcopy(d))</span><br><span class="line">        d_i[i][:,i] = b</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    x = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(b.shape[<span class="number">0</span>]):</span><br><span class="line">        x.append(det(d_i[i]) / det(d))</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p>测试以下方程组：</p><script type="math/tex; mode=display">\begin{cases}2x + y + z = 15\\x + 2y + z =16\\x + y + 2z =17\\\end{cases}</script><p>即：</p><script type="math/tex; mode=display">\left[\begin{array}{ccc|c}2&1&1&15\\1&2&1&16\\1&1&2&17\end{array}\right]</script><p>索引函数的输入为：</p><script type="math/tex; mode=display">d=\begin{vmatrix}2&1&1\\1&2&1\\1&1&2\end{vmatrix} \;\;\;\;\;\;\;\;\;\;\;\;\;\;b = \begin{vmatrix}15\\16\\17\end{vmatrix}</script><p>预测结果：</p><script type="math/tex; mode=display">x = \begin{vmatrix}3&4&5\end{vmatrix}</script><p>运行结果：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = np.array([[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line">b = np.array([<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>])</span><br><span class="line">cramer(d,b)</span><br></pre></td></tr></table></figure><table><tr><td bgcolor=fffffe>[3.0, 4.0, 5.0]</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> 机器学习的数学基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 线性代数 </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
