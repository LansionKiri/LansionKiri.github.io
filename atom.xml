<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我要到物业去告你</title>
  
  <subtitle>我又要到物业去告你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="lasion.top/"/>
  <updated>2020-03-07T12:14:08.628Z</updated>
  <id>lasion.top/</id>
  
  <author>
    <name>Lasion</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python实现基本的矩阵运算</title>
    <link href="lasion.top/python%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97.html"/>
    <id>lasion.top/python%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97.html</id>
    <published>2020-03-07T07:38:14.319Z</published>
    <updated>2020-03-07T12:14:08.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍了矩阵的定义以及基本运算，并用python实现矩阵的运算。线性代数是机器学习的数学基础，而矩阵则是线代的基本，本文按照从理论知识到代码实践的思路，给大家讲解矩阵，并运用到编程中。</p><a id="more"></a><blockquote><p>首先声明矩阵的构建运算均在numpy模块中由相应的函数，而本文的目的主要是因为闲的无聊</p></blockquote><h1 id="矩阵及其运算"><a href="#矩阵及其运算" class="headerlink" title="矩阵及其运算"></a>矩阵及其运算</h1><h2 id="什么是矩阵？"><a href="#什么是矩阵？" class="headerlink" title="什么是矩阵？"></a>什么是矩阵？</h2><ul><li><strong>由$m{\times}n$个&emsp; $a_{ij}$(i=1,2,${\cdots}$,m;j=1,2,${\cdots}$,n)&emsp;数排列成的m行n列的数表</strong></li></ul><script type="math/tex; mode=display">A=\begin{bmatrix}{a_{11} } & {a_{12} } & {\cdots} & {a_{1n} }\\{a_{21} } & {a_{22} } & {\cdots} & {a_{2n} }\\{\vdots} & {\vdots} & {\ddots} & {\vdots}\\{a_{m1} } & {a_{m2} } & {\cdots} & {a_{mn} }\\\end{bmatrix}记作{A_{m*n} }</script><table><tr><td bgcolor=FFFFEE><font face="楷体">    这m×n个数称为矩阵A的<font face="楷体" color=#ff2222>    元素（元）</font></font></td></tr></table><h2 id="矩阵基本运算"><a href="#矩阵基本运算" class="headerlink" title="矩阵基本运算"></a>矩阵基本运算</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><ul><li>两个$m{\times}n$的矩阵相加，即对应元素相加</li></ul><script type="math/tex; mode=display">\begin{bmatrix}{a_{11}} & {a_{12}} & {\cdots} & {a_{1n}}\\ {a_{21}} & {a_{22}} & {\cdots} & {a_{2n}}\\{\vdots} & {\vdots} & {\ddots} & {\vdots}\\{a_{m1}} & {a_{m2}} & {\cdots} & {a_{mn}}\\\end{bmatrix}+\begin{bmatrix}{b_{11}} & {b_{12}} & {\cdots} & {b_{1n}}\\ {b_{21}} & {b_{22}} & {\cdots} & {b_{2n}}\\{\vdots} & {\vdots} & {\ddots} & {\vdots}\\{b_{m1}} & {b_{m2}} & {\cdots} & {b_{mn}}\\\end{bmatrix}=\begin{bmatrix}{a_{11}+b_{11}} & {a_{12}+b_{12}} & {\cdots} & {a_{1n}+b_{1n}}\\ {a_{21}+b_{21}} & {a_{22}+b_{22}} & {\cdots} & {a_{2n}+b_{2n}}\\{\vdots} & {\vdots} & {\ddots} & {\vdots}\\{a_{m1}+b_{m1}} & {a_{m2}+b_{m2}} & {\cdots} & {a_{mn}+b_{mn}}\\\end{bmatrix}\label{eq:jiafa}</script><blockquote><p>加法满足：</p><ol><li>$A + B = B + A$ (交换律)</li><li>$(A + B) + C = A + (B + C)$  （结合律）</li></ol></blockquote><h3 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h3><ul><li>数$\lambda$与矩阵$A$的乘积记作$\lambda A$或$A \lambda$</li></ul><script type="math/tex; mode=display">\lambda A = A \lambda=\begin{bmatrix}{\lambda a_{11}} & {\lambda a_{12}} & {\cdots} & {\lambda a_{1n}}\\{\lambda a_{21}} & {\lambda a_{22}} & {\cdots} & {\lambda a_{2n}}\\{\vdots} & {\vdots} & {\ddots} & {\vdots}\\{\lambda a_{m1}} & {\lambda a_{m2}} & {\cdots} & {\lambda a_{mn}}\\\end{bmatrix}\label{eq:shucheng}</script><blockquote><p>数乘满足：</p><ol><li>$(\lambda \mu)A = \lambda (\mu A)$&emsp;<strong>$\lambda \mu$为常数</strong></li><li>$(\lambda \mu)A = \lambda A + \mu A$</li><li>$\lambda (A+B) = \lambda A + \lambda B$</li></ol></blockquote><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><h4 id="Hadamard乘积"><a href="#Hadamard乘积" class="headerlink" title="Hadamard乘积"></a>Hadamard乘积</h4><ul><li>两个同型矩阵中对应元素乘积，记作$A\bigodot B$</li></ul><script type="math/tex; mode=display">\begin{bmatrix}{a_{11}} & {a_{12}} & {\cdots} & {a_{1n}}\\ {a_{21}} & {a_{22}} & {\cdots} & {a_{2n}}\\{\vdots} & {\vdots} & {\ddots} & {\vdots}\\{a_{m1}} & {a_{m2}} & {\cdots} & {a_{mn}}\\\end{bmatrix}+\begin{bmatrix}{b_{11}} & {b_{12}} & {\cdots} & {b_{1n}}\\ {b_{21}} & {b_{22}} & {\cdots} & {b_{2n}}\\{\vdots} & {\vdots} & {\ddots} & {\vdots}\\{b_{m1}} & {b_{m2}} & {\cdots} & {b_{mn}}\\\end{bmatrix}=\begin{bmatrix}{a_{11}{\times}b_{11}} & {a_{12}{\times}b_{12}} & {\cdots} & {a_{1n}{\times}b_{1n}}\\ {a_{21}{\times}b_{21}} & {a_{22}{\times}b_{22}} & {\cdots} & {a_{2n}{\times}b_{2n}}\\{\vdots} & {\vdots} & {\ddots} & {\vdots}\\{a_{m1}{\times}b_{m1}} & {a_{m2}{\times}b_{m2}} & {\cdots} & {a_{mn}{\times}b_{mn}}\\\end{bmatrix}\label{eq:had}</script><h4 id="点积"><a href="#点积" class="headerlink" title="点积"></a>点积</h4><ul><li>$A=(a_{ij})$是$m{\times}s$矩阵，$B=(b_{ij})$是$s{\times}n$矩阵<br/>规定矩阵$A$与矩阵$B$的乘积$m{\times}n$矩阵$C=(c_{ij})$,其中:<br/></li></ul><script type="math/tex; mode=display">\boxed{c_{ij} = a_{i1}b_{1j}+a_{i2}b_{2j}+{\cdots}+a_{is}b_{sj}\\\quad =\displaystyle \sum^{s}_{k=1}{a_{ik}b_{kj}}(i=1,2,{\cdots},m;j=1,2,{\cdots},n)}\label{eq:dianji}</script><blockquote><p>矩阵点积满足：</p><ol><li>$(AB)C=A(BC)$</li><li>$\lambda (AB) = (\lambda A)B = A(\lambda B)$</li><li>$A(B+C) = AB + AC  \;\;\;(B+C)A = BA + CA$</li><li><strong>$AB\neq BA$</strong></li></ol></blockquote><table><tr><td bgcolor=FFFFEE><font face="楷体" color=#ff2222 size=5><center>    矩阵相乘不满足交换律</center></font></td></tr></table><h1 id="python实现矩阵基本运算思路及代码"><a href="#python实现矩阵基本运算思路及代码" class="headerlink" title="python实现矩阵基本运算思路及代码"></a>python实现矩阵基本运算思路及代码</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p><strong>Anaconda 3 + Python 3.6.5 +  Jupyter</strong></p><h2 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="加法-1"><a href="#加法-1" class="headerlink" title="加法"></a>加法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>参考矩阵加法公式$\eqref{eq:jiafa}$</li></ul><blockquote><ol><li>先判断两矩阵能否相加</li><li>遍历两个矩阵</li><li>各相同位置元素相加</li></ol></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(a.shape != b.shape):</span><br><span class="line">        print(<span class="string">'两矩阵不为同型矩阵！'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    c = np.zeros(a.shape)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(a.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(a.shape[<span class="number">1</span>]):</span><br><span class="line">            c[i][j] = a[i][j] + b[i][j]</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure><h2 id="数乘-1"><a href="#数乘-1" class="headerlink" title="数乘"></a>数乘</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>参考矩阵数乘公式$\eqref{eq:shucheng}$</li></ul><blockquote><ol><li>遍历矩阵</li><li>相乘</li></ol></blockquote><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSub</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    c = np.zeros(a.shape)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(a.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(a.shape[<span class="number">1</span>]):</span><br><span class="line">            c[i][j] = a[i][j] * b</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure><h2 id="Hadamard乘积-1"><a href="#Hadamard乘积-1" class="headerlink" title="Hadamard乘积"></a>Hadamard乘积</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>参考Hadamard乘积公式$\eqref{eq:had}$</li></ul><blockquote><p>与矩阵加法思路一致</p></blockquote><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵对应元素相乘 Hadamard乘积</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">had</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(a.shape != b.shape):</span><br><span class="line">        print(<span class="string">'两矩阵不为同型矩阵！'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    c = np.zeros(a.shape)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(c.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(c.shape[<span class="number">1</span>]):</span><br><span class="line">            c[i][j] = a[i][j] * b[i][j]</span><br></pre></td></tr></table></figure><h2 id="点积-1"><a href="#点积-1" class="headerlink" title="点积"></a>点积</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul><li>参考矩阵点积公式$\eqref{eq:dianji}$</li></ul><blockquote><p>理解公式：乘积C的第m行第n列的元素等于矩阵A的第m行的元素与矩阵B的第n列对应元素乘积之和。</p><ol><li>判断两矩阵是否为同型矩阵</li><li>构建m行n列的结果矩阵</li><li>向结果矩阵中赋值:<br>(1). 遍历结果矩阵<br>(2). 求出矩阵A对应行与矩阵B对应列的元素乘积之和:<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据公式，A矩阵的行与B矩阵的列均确定，因此根据累加条件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遍历两个矩阵来确定另一个索引位置，并累加求和</li></ol></blockquote><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵相乘</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(a.shape[<span class="number">1</span>] != b.shape[<span class="number">0</span>]):</span><br><span class="line">        print(<span class="string">'两矩阵不能相乘'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    m = a.shape[<span class="number">0</span>]</span><br><span class="line">    n = b.shape[<span class="number">1</span>]</span><br><span class="line">    s = a.shape[<span class="number">1</span>]</span><br><span class="line">    c = np.zeros((m,n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(s):</span><br><span class="line">                c[i][j] += a[i][k]*b[k][j]</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了矩阵的定义以及基本运算，并用python实现矩阵的运算。线性代数是机器学习的数学基础，而矩阵则是线代的基本，本文按照从理论知识到代码实践的思路，给大家讲解矩阵，并运用到编程中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习的数学基础" scheme="lasion.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="机器学习" scheme="lasion.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="线性代数" scheme="lasion.top/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="python" scheme="lasion.top/tags/python/"/>
    
      <category term="矩阵" scheme="lasion.top/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>python实现基本的矩阵运算</title>
    <link href="lasion.top/python%E6%B1%82%E7%9F%A9%E9%98%B5%E7%9A%84%E9%80%86.html"/>
    <id>lasion.top/python%E6%B1%82%E7%9F%A9%E9%98%B5%E7%9A%84%E9%80%86.html</id>
    <published>2020-03-07T07:38:14.319Z</published>
    <updated>2020-03-09T00:28:04.294Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍了矩阵的逆定义，并用python实现求矩阵的逆。同时讲到了代数余子式、伴随矩阵。并用python语言实现。其实在numpy中有求矩阵的逆的函数，而本文则是介绍矩阵的逆，并编程自己实现来提高自己的编程水平</p><a id="more"></a><h1 id="准备工作-Ready-to-work"><a href="#准备工作-Ready-to-work" class="headerlink" title="准备工作 Ready to work"></a>准备工作 Ready to work</h1><h2 id="环境-Environment"><a href="#环境-Environment" class="headerlink" title="环境 Environment"></a>环境 Environment</h2><p><strong>Anaconda 3 + Python 3.6.5 +  Jupyter</strong></p><h2 id="模块导入-Module-import"><a href="#模块导入-Module-import" class="headerlink" title="模块导入 Module import"></a>模块导入 Module import</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv</span><br></pre></td></tr></table></figure><h1 id="代数余子式-Algebraic-cofactor"><a href="#代数余子式-Algebraic-cofactor" class="headerlink" title="代数余子式 Algebraic cofactor"></a>代数余子式 Algebraic cofactor</h1><h2 id="定义-Definition"><a href="#定义-Definition" class="headerlink" title="定义 Definition"></a>定义 Definition</h2><ul><li><p><strong>定义：在n阶行列式，把$\;(i,j)\;$元$\;a_{ij}\;$所在的第i行和第j列划去后，留下来的n-1阶行列式叫做$\;(i,j)\;$元$\;a_{ij}\;$的余子式，记作$\;M_{ij}\;$</strong></p></li><li><p><strong>$\bf A_{ij} = (-1)^{i+j}M_{ij}\;$叫做$\;(i,j)\;$元$\;a_{ij}\;$的代数余子式</strong></p></li></ul><script type="math/tex; mode=display">\bf D = \begin{vmatrix}{a_{11}} & {a_{12}} & {\cdots} & {a_{1j}}  & {\cdots} & {a_{1n}}\\{a_{21}} & {a_{22}} & {\cdots} & {a_{2j}}  & {\cdots} & {a_{2n}}\\\vdots&\vdots&&\vdots&&\vdots\\{a_{i1}} & {a_{i2}} & {\cdots} & {a_{ij}}  & {\cdots} & {a_{i-1n}}\\\vdots&\vdots&&\vdots&&\vdots\\{a_{m1}} & {a_{m2}} & {\cdots} & {a_{mj}}  & {\cdots} & {a_{mn}}\\\end{vmatrix}</script><ul><li>$\bf D$中$\;(i,j)\;$元$\;\bf a_{ij}\;$的余子式和代数余子式分别为：</li></ul><script type="math/tex; mode=display">\bf M_{ij} = \begin{vmatrix}{a_{11}} & {a_{12}} & {\cdots} & {a_{1\;j-1}} & {a_{i\;j+1}} & {\cdots} & {a_{1n}}\\{a_{21}} & {a_{22}} & {\cdots} & {a_{2\;j-1}} & {a_{2\;j+1}} & {\cdots} & {a_{2n}}\\\vdots&\vdots&&\vdots&\vdots&&\vdots\\{a_{i-1\;1}} & {a_{i-1\;2}} & {\cdots} & {a_{i-1\;j-1}} & {a_{i-1\;j+1}} & {\cdots} & {a_{i-1n}}\\{a_{i+1\;1}} & {a_{i+1\;2}} & {\cdots} & {a_{i+1\;j-1}} & {a_{i+1\;j+1}} & {\cdots} & {a_{i+1n}}\\\vdots&\vdots&&\vdots&\vdots&&\vdots\\{a_{m1}} & {a_{m2}} & {\cdots} & {a_{m\;j-1}} & {a_{m\;j+1}} & {\cdots} & {a_{mn}}\\\end{vmatrix}\;\;\;\;A_{ij} = (-1)^{i+j}M_{ij}</script><h2 id="代码实现-Code"><a href="#代码实现-Code" class="headerlink" title="代码实现 Code"></a>代码实现 Code</h2><h3 id="余子式-Cofactor"><a href="#余子式-Cofactor" class="headerlink" title="余子式 Cofactor"></a>余子式 Cofactor</h3><table><tr><td bgcolor=FFFFEE><font face="楷体">    先求出给定矩阵的余子式，即去除指定的行和列，然后根据公式求出代数余子式。<center>提供两种实现思路</center></font></td></tr></table><ul><li>通过遍历实现，但不遍历整个矩阵。</li></ul><blockquote><p>变量说明:</p><ol><li>M：原始矩阵</li><li>index：指定元素的索引，长度为2的向量</li><li>temp：M中的每个行向量</li><li>det()：求行列式的函数</li></ol><p>思路：</p><ol><li><p>创建一个n-1阶的方阵（result）用于存放最后结果</p></li><li><p>通过遍历向result中按行赋值：</p><ul><li><p>先判断是否为要消去的一行，如果是跳过本次循环</p></li><li><p>遍历原矩阵并取出其中的行向量</p></li><li>将行向量切片，以index[0]为界限且不包含index[0]</li><li>将两个一位矩阵片段拼接并对应放入result中</li><li>返回result行列式的值</li></ul></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cof</span><span class="params">(M,index)</span>:</span></span><br><span class="line">    result = np.zeros((M.shape[<span class="number">0</span>]<span class="number">-1</span>,M.shape[<span class="number">1</span>]<span class="number">-1</span>))  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M.shape[<span class="number">0</span>]):</span><br><span class="line">        temp = copy.deepcopy(M[i])</span><br><span class="line">        <span class="keyword">if</span> i==index[<span class="number">0</span>]<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= index[<span class="number">0</span>]:</span><br><span class="line">            Ri = i<span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Ri = i</span><br><span class="line">        result[Ri] = np.append(temp[:index[<span class="number">1</span>]<span class="number">-1</span>],temp[index[<span class="number">1</span>]:])</span><br><span class="line">    <span class="keyword">return</span> det(result)</span><br></pre></td></tr></table></figure><ul><li>通过numpy自带方法对矩阵进行重组</li></ul><blockquote><ol><li>首先按照index的两个值作为x、y轴，对矩阵进行切片，将原始矩阵分为左上、右上、左下、右下四个矩阵</li><li>利用numpy.concatenate()函数对四个矩阵进行拼接：<ul><li>numpy.concatenate()有两个参数，第一个参数是矩阵列表，是要拼接的矩阵；第二个参数axis，axis=1表示对应行的数组进行拼接，axis=0表示对对应列进行拼接，默认为0</li><li>首先将左上、右上两个矩阵按行拼接组成结果矩阵的上半部分</li><li>同理求出结果矩阵的下半部分</li><li>最后将result的上下两部分按列拼接，返回result的行列式的值</li></ul></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cof1</span><span class="params">(M,index)</span>:</span></span><br><span class="line">    zs = M[:index[<span class="number">0</span>]<span class="number">-1</span>,:index[<span class="number">1</span>]<span class="number">-1</span>]</span><br><span class="line">    ys = M[:index[<span class="number">0</span>]<span class="number">-1</span>,index[<span class="number">1</span>]:]</span><br><span class="line">    zx = M[index[<span class="number">0</span>]:,:index[<span class="number">1</span>]<span class="number">-1</span>]</span><br><span class="line">    yx = M[index[<span class="number">0</span>]:,index[<span class="number">1</span>]:]</span><br><span class="line">    s = np.concatenate((zs,ys),axis=<span class="number">1</span>)</span><br><span class="line">    x = np.concatenate((zx,yx),axis=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> det(np.concatenate((s,x),axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure><h3 id="代数余子式-Algebraic-cofactor-1"><a href="#代数余子式-Algebraic-cofactor-1" class="headerlink" title="代数余子式 Algebraic cofactor"></a>代数余子式 Algebraic cofactor</h3><ul><li>参考公式</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alcof</span><span class="params">(M,index)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> pow(<span class="number">-1</span>,index[<span class="number">0</span>]+index[<span class="number">1</span>])*cof(M,index)</span><br></pre></td></tr></table></figure><h1 id="伴随矩阵-Adjoint-matrix"><a href="#伴随矩阵-Adjoint-matrix" class="headerlink" title="伴随矩阵 Adjoint matrix"></a>伴随矩阵 Adjoint matrix</h1><h2 id="定义-Definition-1"><a href="#定义-Definition-1" class="headerlink" title="定义 Definition"></a>定义 Definition</h2><ul><li><strong>定义：行列式$\; \begin{vmatrix} A \end{vmatrix}\;$的各个元素的代数余子式$\;A_{ij}\;$构成的矩阵。</strong></li></ul><script type="math/tex; mode=display">adj(\bf C) = \begin{bmatrix}A_{11} & A_{21} & \cdots & A_{n1}\\A_{12} & A_{22} & \cdots & A_{n2}\\\vdots & \vdots && \vdots\\A_{1n} & A_{2n} & \cdots & A_{nn}\\\end{bmatrix} \;\;\;\;\;\;\;\;\;\;\;A_{ij}是C_{ij}的代数余子式</script><p>称为C的伴随矩阵，简称伴随阵，记作$C^*$</p><blockquote><p>伴随矩阵满足：</p><ul><li><script type="math/tex; mode=display">AA^* = A*A = \begin{vmatrix}A\end{vmatrix}E</script></li></ul></blockquote><h2 id="代码实现-Code-1"><a href="#代码实现-Code-1" class="headerlink" title="代码实现 Code"></a>代码实现 Code</h2><ul><li>分析公式可以看出伴随矩阵的形状与原始矩阵相同，伴随矩阵(i,j)位置上的元是原始矩阵(j,i)位置上元的代数余子式</li></ul><blockquote><p>思路：</p><ol><li>创建一个与原始矩阵形状相同的矩阵result</li><li>通过向result中填充数据</li></ol></blockquote><ul><li><strong>注：矩阵下标从1开始，而在代码中索引均从0开始</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adj</span><span class="params">(M)</span>:</span></span><br><span class="line">    result = np.zeros((M.shape[<span class="number">0</span>],M.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,M.shape[<span class="number">0</span>]+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,M.shape[<span class="number">1</span>]+<span class="number">1</span>):</span><br><span class="line">            result[j<span class="number">-1</span>][i<span class="number">-1</span>] = alcof(copy.deepcopy(M),[i,j])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="矩阵的逆-Inverse-of-matrix"><a href="#矩阵的逆-Inverse-of-matrix" class="headerlink" title="矩阵的逆 Inverse of matrix"></a>矩阵的逆 Inverse of matrix</h1><h2 id="定义-Definition-2"><a href="#定义-Definition-2" class="headerlink" title="定义 Definition"></a>定义 Definition</h2><ul><li><strong>定义：对于n阶矩阵A，如果有一个n阶矩阵B使其满足以下条件，则说矩阵A是可逆的，B是A的逆矩阵，简称逆阵。</strong></li></ul><script type="math/tex; mode=display">\bf AB=BA=E</script><ul><li><p><strong>A的逆记作$\bf A^{-1}$</strong></p></li><li><p><strong>定理1：若矩阵A可逆，则$\bf \begin{vmatrix} A\end{vmatrix} \neq 0$</strong></p></li><li><p><strong>定理2：若$\bf \begin{vmatrix} A\end{vmatrix} \neq 0$，则A可逆，且：</strong></p></li></ul><script type="math/tex; mode=display">\bf A^{-1} = \frac{1}{\begin{vmatrix} A \end{vmatrix}}A^*</script><ul><li><strong>推论：若$\bf AB=E($或$\bf BA=E)$，则$\bf B=A^*$</strong></li></ul><h2 id="代码实现-Code-2"><a href="#代码实现-Code-2" class="headerlink" title="代码实现 Code"></a>代码实现 Code</h2><ul><li>根据公式原始矩阵对应行列式的值的倒数乘该矩阵的伴随矩阵</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invmat</span><span class="params">(M)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> det(M)!=<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/det(M)*adj(M)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(原始矩阵不能为<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h1 id="测试-程序-Test-program"><a href="#测试-程序-Test-program" class="headerlink" title="测试 程序 Test program"></a>测试 程序 Test program</h1><ul><li>可以调用numpy.linalg.inv()函数来求得原始矩阵的逆，然后调用自己的函数，看两个输出结果是否相同</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv</span><br><span class="line">M = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line">print(inv(M))</span><br><span class="line">print(invmat(M))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了矩阵的逆定义，并用python实现求矩阵的逆。同时讲到了代数余子式、伴随矩阵。并用python语言实现。其实在numpy中有求矩阵的逆的函数，而本文则是介绍矩阵的逆，并编程自己实现来提高自己的编程水平&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习的数学基础" scheme="lasion.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="机器学习" scheme="lasion.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="线性代数" scheme="lasion.top/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="python" scheme="lasion.top/tags/python/"/>
    
      <category term="矩阵" scheme="lasion.top/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>python实现基本的矩阵运算</title>
    <link href="lasion.top/%E5%85%8B%E8%8E%B1%E5%A7%86%E6%B3%95%E5%88%99.html"/>
    <id>lasion.top/%E5%85%8B%E8%8E%B1%E5%A7%86%E6%B3%95%E5%88%99.html</id>
    <published>2020-03-07T07:38:14.319Z</published>
    <updated>2020-03-09T03:54:22.759Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍了克莱姆法则，并用pthon进行实现。克莱姆法则，又译克拉默法则（Cramer’s Rule）是线性代数中一个关于求解线性方程组的定理。它适用于变量和方程数目相等的线性方程组，对于多于两个或三个方程的系统，克莱姆的规则在计算上非常低效；与具有多项式时间复杂度的消除方法相比，其渐近的复杂度为O（n·n！）。</p><a id="more"></a><blockquote><p><strong>注：本文对numpy对象使用append方法时均使用了深拷贝deepcopy，因为python中对象的赋值是按引用传递的，如果不使用深拷贝在append时会改变原有对象从而覆盖原先的值</strong></p></blockquote><h1 id="首先完成python模拟行列式运算"><a href="#首先完成python模拟行列式运算" class="headerlink" title="首先完成python模拟行列式运算"></a>首先完成python模拟行列式运算</h1><script type="math/tex; mode=display">\begin{vmatrix}{a_{11}}&{a_{12}}&{\cdots}&{a_1n}\\{a_{21}}&{a_{22}}&{\cdots}&{a_2n}\\{\vdots}&{\vdots}&{\ddots}&{\vdots}\\{a_{n1}}&{a_{n2}}&{\cdots}&{a_{nn}}\\\end{vmatrix}= \sum{(-1)^{t}}{a_{1p_{1}}a_{2p_{2}}}{\cdots}{a_{np_{n}}}</script><blockquote><p>标注：t:&emsp;${p_1}{p_2}{p_3}{\cdots}{p_n}$ 的逆序数</p></blockquote><h2 id="公式分析"><a href="#公式分析" class="headerlink" title="公式分析"></a>公式分析</h2><p><strong>${p_1}{p_2}{p_3}{\cdots}{p_n}$从下标来看可以看作n个数的全排列，而t则是后面下标序列的逆序数，所以我们可以将他分成三个模块来实现，首先是求的我们所需的全排列序列，然后对该序列求逆序数，最后累加求和</strong></p><h2 id="模块分析与实现"><a href="#模块分析与实现" class="headerlink" title="模块分析与实现"></a>模块分析与实现</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p><strong>Anaconda 3 + Python 3.6.5 + Jupyter</strong></p><h3 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import copy</span><br></pre></td></tr></table></figure><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><ul><li><p>从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。</p><p>公式：全排列数f(n)=n!(定义0!=1)</p></li></ul><p><a href="https://ae01.alicdn.com/kf/Hc6b02e38d7fe46a78ff3a32959efbd823.png" target="_blank" rel="noopener"><img src="https://ae01.alicdn.com/kf/Hc6b02e38d7fe46a78ff3a32959efbd823.png" alt="https://ae01.alicdn.com/kf/Hc6b02e38d7fe46a78ff3a32959efbd823.png"></a></p><p>(深度优先搜索)采用递归的思路:先确定一个节点，然后后面的节点进行交换，在确定下一个节点，一层层递归，递归回溯时应将顺序交换回来，以便向其他子节点方向递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全排列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(n)</span>:</span></span><br><span class="line">    arr = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(n)]</span><br><span class="line">    result =[]</span><br><span class="line">    dfs(arr,<span class="number">0</span>,len(arr),result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(arr, begin, end,result)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> begin == end:</span><br><span class="line">        result.append(copy.deepcopy(arr))</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(begin,end):</span><br><span class="line">            arr[i],arr[begin] = arr[begin],arr[i]</span><br><span class="line">            dfs(arr,begin+<span class="number">1</span>,end,result)</span><br><span class="line">            arr[i],arr[begin] = arr[begin],arr[i]</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h3><ul><li>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个<strong>逆序</strong>。一个排列中逆序的总数就称为这个排列的<strong>逆序数</strong>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逆序数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverse</span><span class="params">(arr)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[i]:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">pass</span>    </span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="方阵计算"><a href="#方阵计算" class="headerlink" title="方阵计算"></a>方阵计算</h3><ul><li>根据公式进行累加计算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">det</span><span class="params">(matrix)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> matrix.shape[<span class="number">0</span>]!=matrix.shape[<span class="number">1</span>]:</span><br><span class="line">        print(<span class="string">'此矩阵不是方阵！'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    permutation = permutations(matrix.shape[<span class="number">0</span>])</span><br><span class="line">    permutation = np.array(permutation)</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(permutation)):</span><br><span class="line">        a = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(matrix.shape[<span class="number">0</span>]):</span><br><span class="line">            a*=matrix[j][permutation[i][j]]</span><br><span class="line">        result += pow(<span class="number">-1</span>,inverse(permutation[i]))*a</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="克莱姆法则-Cramer’s-rule"><a href="#克莱姆法则-Cramer’s-rule" class="headerlink" title="克莱姆法则 Cramer’s rule"></a>克莱姆法则 <em>Cramer’s rule</em></h1><p><strong>对以下方程组：</strong></p><script type="math/tex; mode=display">\begin{cases}a_{11}x_1 + a_{12}x_2 + {\cdots} + a_{1n}x_n = b_1\\a_{21}x_1 + a_{22}x_2 + {\cdots} + a_{2n}x_n = b_2\\{\cdots}{\cdots}\\a_{n1}x_1 + a_{n2}x_2 + {\cdots} + a_{nn}x_n = b_n\\\end{cases}</script><p><strong><em><font color=red>如果线性方程组的系数行列式D不为零，即：</font></em></strong></p><script type="math/tex; mode=display">D=\begin{vmatrix}{a_{11}}&{\cdots}&{a_{1n}}\\{\vdots}&{\ddots}&{\vdots}\\{a_{n1}}&{\cdots}&{a_{nn}}\\\end{vmatrix} {\neq} 0</script><p><strong><em><font color=red>那么方程组有唯一解：</font></em></strong></p><script type="math/tex; mode=display">x_1 = \frac{D_1}{D} , x_2 = \frac{D_2}{D} , {\cdots} , x_n = \frac{D_n}{D}</script><p><strong><em><font color=red>其中&emsp;$D_j$(j=1,2,$\cdots$，n)&emsp;是把行列式D中第j列元素用方程组右端的常数项代替后所得到的n阶行列式，即：</font></em></strong></p><script type="math/tex; mode=display">D_j=\begin{vmatrix}{a_{11}}&{\cdots}&a_{1，j-1}&b_1&{\cdots}&a_{1n}\\{\vdots}&&{\vdots}&{\vdots}&&{\vdots}\\{a_{n1}}&{\cdots}&a_{n，j-1}&b_1&{\cdots}&a_{nn}\\\end{vmatrix}</script><blockquote><p><strong>对此我们做出如下约定：</strong></p><ol><li>d为系数矩阵作为函数的第一个参数</li><li>b为方程组右端常数项组成的列向量作为函数的第二个参数</li><li>d_i为公式中的&emsp;$D_j$(j=1,2,$\cdots$，n)&emsp;组成的三维矩阵</li><li>返回由结果&emsp;$x_i$(j=i,2,$\cdots$，n)&emsp;组成的向量</li></ol></blockquote><p><strong>实现代码：</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cramer</span><span class="params">(d,b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> d.shape[<span class="number">0</span>]!=d.shape[<span class="number">1</span>]:</span><br><span class="line">        print(<span class="string">'此矩阵不是方阵！'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> det(d) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'系数方阵为0'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    d_i = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(b.shape[<span class="number">0</span>]):</span><br><span class="line">        d_i.append(copy.deepcopy(d))</span><br><span class="line">        d_i[i][:,i] = b</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    x = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(b.shape[<span class="number">0</span>]):</span><br><span class="line">        x.append(det(d_i[i]) / det(d))</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p>测试以下方程组：</p><script type="math/tex; mode=display">\begin{cases}2x + y + z = 15\\x + 2y + z =16\\x + y + 2z =17\\\end{cases}</script><p>即：</p><script type="math/tex; mode=display">\left[\begin{array}{ccc|c}2&1&1&15\\1&2&1&16\\1&1&2&17\end{array}\right]</script><p>索引函数的输入为：</p><script type="math/tex; mode=display">d=\begin{vmatrix}2&1&1\\1&2&1\\1&1&2\end{vmatrix} \;\;\;\;\;\;\;\;\;\;\;\;\;\;b = \begin{vmatrix}15\\16\\17\end{vmatrix}</script><p>预测结果：</p><script type="math/tex; mode=display">x = \begin{vmatrix}3&4&5\end{vmatrix}</script><p>运行结果：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = np.array([[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line">b = np.array([<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>])</span><br><span class="line">cramer(d,b)</span><br></pre></td></tr></table></figure><table><tr><td bgcolor=fffffe>[3.0, 4.0, 5.0]</td></tr></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了克莱姆法则，并用pthon进行实现。克莱姆法则，又译克拉默法则（Cramer’s Rule）是线性代数中一个关于求解线性方程组的定理。它适用于变量和方程数目相等的线性方程组，对于多于两个或三个方程的系统，克莱姆的规则在计算上非常低效；与具有多项式时间复杂度的消除方法相比，其渐近的复杂度为O（n·n！）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习的数学基础" scheme="lasion.top/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="机器学习" scheme="lasion.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="线性代数" scheme="lasion.top/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="python" scheme="lasion.top/tags/python/"/>
    
      <category term="矩阵" scheme="lasion.top/tags/%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
</feed>
